// This file is generated by rust-protobuf 2.18.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/config/internal/config.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_0;

#[derive(PartialEq,Clone,Default)]
pub struct DNS {
    // message fields
    pub servers: ::protobuf::RepeatedField<::std::string::String>,
    pub bind: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DNS {
    fn default() -> &'a DNS {
        <DNS as ::protobuf::Message>::default_instance()
    }
}

impl DNS {
    pub fn new() -> DNS {
        ::std::default::Default::default()
    }

    // repeated string servers = 1;


    pub fn get_servers(&self) -> &[::std::string::String] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }

    // string bind = 2;


    pub fn get_bind(&self) -> &str {
        &self.bind
    }
    pub fn clear_bind(&mut self) {
        self.bind.clear();
    }

    // Param is passed by value, moved
    pub fn set_bind(&mut self, v: ::std::string::String) {
        self.bind = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bind(&mut self) -> &mut ::std::string::String {
        &mut self.bind
    }

    // Take field
    pub fn take_bind(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bind, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DNS {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.servers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.bind.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bind);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_string(1, &v)?;
        };
        if !self.bind.is_empty() {
            os.write_string(2, &self.bind)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DNS {
        DNS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "servers",
                |m: &DNS| { &m.servers },
                |m: &mut DNS| { &mut m.servers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bind",
                |m: &DNS| { &m.bind },
                |m: &mut DNS| { &mut m.bind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DNS>(
                "DNS",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DNS {
        static instance: ::protobuf::rt::LazyV2<DNS> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DNS::new)
    }
}

impl ::protobuf::Clear for DNS {
    fn clear(&mut self) {
        self.servers.clear();
        self.bind.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DNS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DNS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Log {
    // message fields
    pub level: Log_Level,
    pub output: Log_Output,
    pub output_file: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Log {
    fn default() -> &'a Log {
        <Log as ::protobuf::Message>::default_instance()
    }
}

impl Log {
    pub fn new() -> Log {
        ::std::default::Default::default()
    }

    // .Log.Level level = 1;


    pub fn get_level(&self) -> Log_Level {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = Log_Level::TRACE;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: Log_Level) {
        self.level = v;
    }

    // .Log.Output output = 2;


    pub fn get_output(&self) -> Log_Output {
        self.output
    }
    pub fn clear_output(&mut self) {
        self.output = Log_Output::CONSOLE;
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: Log_Output) {
        self.output = v;
    }

    // string output_file = 3;


    pub fn get_output_file(&self) -> &str {
        &self.output_file
    }
    pub fn clear_output_file(&mut self) {
        self.output_file.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_file(&mut self, v: ::std::string::String) {
        self.output_file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_file(&mut self) -> &mut ::std::string::String {
        &mut self.output_file
    }

    // Take field
    pub fn take_output_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output_file, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Log {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.output, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != Log_Level::TRACE {
            my_size += ::protobuf::rt::enum_size(1, self.level);
        }
        if self.output != Log_Output::CONSOLE {
            my_size += ::protobuf::rt::enum_size(2, self.output);
        }
        if !self.output_file.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.output_file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != Log_Level::TRACE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        if self.output != Log_Output::CONSOLE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.output))?;
        }
        if !self.output_file.is_empty() {
            os.write_string(3, &self.output_file)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Log {
        Log::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Log_Level>>(
                "level",
                |m: &Log| { &m.level },
                |m: &mut Log| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Log_Output>>(
                "output",
                |m: &Log| { &m.output },
                |m: &mut Log| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output_file",
                |m: &Log| { &m.output_file },
                |m: &mut Log| { &mut m.output_file },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Log>(
                "Log",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Log {
        static instance: ::protobuf::rt::LazyV2<Log> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Log::new)
    }
}

impl ::protobuf::Clear for Log {
    fn clear(&mut self) {
        self.level = Log_Level::TRACE;
        self.output = Log_Output::CONSOLE;
        self.output_file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Log {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Log {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Log_Level {
    TRACE = 0,
    DEBUG = 1,
    INFO = 2,
    WARN = 3,
    ERROR = 4,
}

impl ::protobuf::ProtobufEnum for Log_Level {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Log_Level> {
        match value {
            0 => ::std::option::Option::Some(Log_Level::TRACE),
            1 => ::std::option::Option::Some(Log_Level::DEBUG),
            2 => ::std::option::Option::Some(Log_Level::INFO),
            3 => ::std::option::Option::Some(Log_Level::WARN),
            4 => ::std::option::Option::Some(Log_Level::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Log_Level] = &[
            Log_Level::TRACE,
            Log_Level::DEBUG,
            Log_Level::INFO,
            Log_Level::WARN,
            Log_Level::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Log_Level>("Log.Level", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Log_Level {
}

impl ::std::default::Default for Log_Level {
    fn default() -> Self {
        Log_Level::TRACE
    }
}

impl ::protobuf::reflect::ProtobufValue for Log_Level {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Log_Output {
    CONSOLE = 0,
    FILE = 1,
}

impl ::protobuf::ProtobufEnum for Log_Output {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Log_Output> {
        match value {
            0 => ::std::option::Option::Some(Log_Output::CONSOLE),
            1 => ::std::option::Option::Some(Log_Output::FILE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Log_Output] = &[
            Log_Output::CONSOLE,
            Log_Output::FILE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Log_Output>("Log.Output", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Log_Output {
}

impl ::std::default::Default for Log_Output {
    fn default() -> Self {
        Log_Output::CONSOLE
    }
}

impl ::protobuf::reflect::ProtobufValue for Log_Output {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TUNInboundSettings {
    // message fields
    pub fd: i32,
    pub name: ::std::string::String,
    pub address: ::std::string::String,
    pub gateway: ::std::string::String,
    pub netmask: ::std::string::String,
    pub mtu: i32,
    pub fake_dns_exclude: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TUNInboundSettings {
    fn default() -> &'a TUNInboundSettings {
        <TUNInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TUNInboundSettings {
    pub fn new() -> TUNInboundSettings {
        ::std::default::Default::default()
    }

    // int32 fd = 1;


    pub fn get_fd(&self) -> i32 {
        self.fd
    }
    pub fn clear_fd(&mut self) {
        self.fd = 0;
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: i32) {
        self.fd = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string gateway = 4;


    pub fn get_gateway(&self) -> &str {
        &self.gateway
    }
    pub fn clear_gateway(&mut self) {
        self.gateway.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway(&mut self, v: ::std::string::String) {
        self.gateway = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway(&mut self) -> &mut ::std::string::String {
        &mut self.gateway
    }

    // Take field
    pub fn take_gateway(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gateway, ::std::string::String::new())
    }

    // string netmask = 5;


    pub fn get_netmask(&self) -> &str {
        &self.netmask
    }
    pub fn clear_netmask(&mut self) {
        self.netmask.clear();
    }

    // Param is passed by value, moved
    pub fn set_netmask(&mut self, v: ::std::string::String) {
        self.netmask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_netmask(&mut self) -> &mut ::std::string::String {
        &mut self.netmask
    }

    // Take field
    pub fn take_netmask(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.netmask, ::std::string::String::new())
    }

    // int32 mtu = 6;


    pub fn get_mtu(&self) -> i32 {
        self.mtu
    }
    pub fn clear_mtu(&mut self) {
        self.mtu = 0;
    }

    // Param is passed by value, moved
    pub fn set_mtu(&mut self, v: i32) {
        self.mtu = v;
    }

    // repeated string fake_dns_exclude = 7;


    pub fn get_fake_dns_exclude(&self) -> &[::std::string::String] {
        &self.fake_dns_exclude
    }
    pub fn clear_fake_dns_exclude(&mut self) {
        self.fake_dns_exclude.clear();
    }

    // Param is passed by value, moved
    pub fn set_fake_dns_exclude(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fake_dns_exclude = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fake_dns_exclude(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fake_dns_exclude
    }

    // Take field
    pub fn take_fake_dns_exclude(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fake_dns_exclude, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TUNInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fd = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gateway)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.netmask)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mtu = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fake_dns_exclude)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fd != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fd, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if !self.gateway.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.gateway);
        }
        if !self.netmask.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.netmask);
        }
        if self.mtu != 0 {
            my_size += ::protobuf::rt::value_size(6, self.mtu, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fake_dns_exclude {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fd != 0 {
            os.write_int32(1, self.fd)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if !self.gateway.is_empty() {
            os.write_string(4, &self.gateway)?;
        }
        if !self.netmask.is_empty() {
            os.write_string(5, &self.netmask)?;
        }
        if self.mtu != 0 {
            os.write_int32(6, self.mtu)?;
        }
        for v in &self.fake_dns_exclude {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TUNInboundSettings {
        TUNInboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fd",
                |m: &TUNInboundSettings| { &m.fd },
                |m: &mut TUNInboundSettings| { &mut m.fd },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TUNInboundSettings| { &m.name },
                |m: &mut TUNInboundSettings| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &TUNInboundSettings| { &m.address },
                |m: &mut TUNInboundSettings| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateway",
                |m: &TUNInboundSettings| { &m.gateway },
                |m: &mut TUNInboundSettings| { &mut m.gateway },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "netmask",
                |m: &TUNInboundSettings| { &m.netmask },
                |m: &mut TUNInboundSettings| { &mut m.netmask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mtu",
                |m: &TUNInboundSettings| { &m.mtu },
                |m: &mut TUNInboundSettings| { &mut m.mtu },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fake_dns_exclude",
                |m: &TUNInboundSettings| { &m.fake_dns_exclude },
                |m: &mut TUNInboundSettings| { &mut m.fake_dns_exclude },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TUNInboundSettings>(
                "TUNInboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TUNInboundSettings {
        static instance: ::protobuf::rt::LazyV2<TUNInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TUNInboundSettings::new)
    }
}

impl ::protobuf::Clear for TUNInboundSettings {
    fn clear(&mut self) {
        self.fd = 0;
        self.name.clear();
        self.address.clear();
        self.gateway.clear();
        self.netmask.clear();
        self.mtu = 0;
        self.fake_dns_exclude.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TUNInboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TUNInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SocksInboundSettings {
    // message fields
    pub bind: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SocksInboundSettings {
    fn default() -> &'a SocksInboundSettings {
        <SocksInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl SocksInboundSettings {
    pub fn new() -> SocksInboundSettings {
        ::std::default::Default::default()
    }

    // string bind = 1;


    pub fn get_bind(&self) -> &str {
        &self.bind
    }
    pub fn clear_bind(&mut self) {
        self.bind.clear();
    }

    // Param is passed by value, moved
    pub fn set_bind(&mut self, v: ::std::string::String) {
        self.bind = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bind(&mut self) -> &mut ::std::string::String {
        &mut self.bind
    }

    // Take field
    pub fn take_bind(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bind, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SocksInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bind.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bind);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bind.is_empty() {
            os.write_string(1, &self.bind)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SocksInboundSettings {
        SocksInboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bind",
                |m: &SocksInboundSettings| { &m.bind },
                |m: &mut SocksInboundSettings| { &mut m.bind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SocksInboundSettings>(
                "SocksInboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SocksInboundSettings {
        static instance: ::protobuf::rt::LazyV2<SocksInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SocksInboundSettings::new)
    }
}

impl ::protobuf::Clear for SocksInboundSettings {
    fn clear(&mut self) {
        self.bind.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SocksInboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SocksInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Inbound {
    // message fields
    pub tag: ::std::string::String,
    pub protocol: ::std::string::String,
    pub listen: ::std::string::String,
    pub port: u32,
    pub settings: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Inbound {
    fn default() -> &'a Inbound {
        <Inbound as ::protobuf::Message>::default_instance()
    }
}

impl Inbound {
    pub fn new() -> Inbound {
        ::std::default::Default::default()
    }

    // string tag = 1;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }

    // string protocol = 2;


    pub fn get_protocol(&self) -> &str {
        &self.protocol
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        &mut self.protocol
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocol, ::std::string::String::new())
    }

    // string listen = 3;


    pub fn get_listen(&self) -> &str {
        &self.listen
    }
    pub fn clear_listen(&mut self) {
        self.listen.clear();
    }

    // Param is passed by value, moved
    pub fn set_listen(&mut self, v: ::std::string::String) {
        self.listen = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listen(&mut self) -> &mut ::std::string::String {
        &mut self.listen
    }

    // Take field
    pub fn take_listen(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listen, ::std::string::String::new())
    }

    // uint32 port = 4;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // bytes settings = 5;


    pub fn get_settings(&self) -> &[u8] {
        &self.settings
    }
    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: ::std::vec::Vec<u8>) {
        self.settings = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.settings
    }

    // Take field
    pub fn take_settings(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.settings, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Inbound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocol)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listen)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.protocol);
        }
        if !self.listen.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.listen);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(4, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.settings.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.settings);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if !self.protocol.is_empty() {
            os.write_string(2, &self.protocol)?;
        }
        if !self.listen.is_empty() {
            os.write_string(3, &self.listen)?;
        }
        if self.port != 0 {
            os.write_uint32(4, self.port)?;
        }
        if !self.settings.is_empty() {
            os.write_bytes(5, &self.settings)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Inbound {
        Inbound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &Inbound| { &m.tag },
                |m: &mut Inbound| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &Inbound| { &m.protocol },
                |m: &mut Inbound| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "listen",
                |m: &Inbound| { &m.listen },
                |m: &mut Inbound| { &mut m.listen },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &Inbound| { &m.port },
                |m: &mut Inbound| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "settings",
                |m: &Inbound| { &m.settings },
                |m: &mut Inbound| { &mut m.settings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Inbound>(
                "Inbound",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Inbound {
        static instance: ::protobuf::rt::LazyV2<Inbound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Inbound::new)
    }
}

impl ::protobuf::Clear for Inbound {
    fn clear(&mut self) {
        self.tag.clear();
        self.protocol.clear();
        self.listen.clear();
        self.port = 0;
        self.settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Inbound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Inbound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedirectOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectOutboundSettings {
    fn default() -> &'a RedirectOutboundSettings {
        <RedirectOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl RedirectOutboundSettings {
    pub fn new() -> RedirectOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for RedirectOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectOutboundSettings {
        RedirectOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &RedirectOutboundSettings| { &m.address },
                |m: &mut RedirectOutboundSettings| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &RedirectOutboundSettings| { &m.port },
                |m: &mut RedirectOutboundSettings| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedirectOutboundSettings>(
                "RedirectOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedirectOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<RedirectOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedirectOutboundSettings::new)
    }
}

impl ::protobuf::Clear for RedirectOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SocksOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SocksOutboundSettings {
    fn default() -> &'a SocksOutboundSettings {
        <SocksOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl SocksOutboundSettings {
    pub fn new() -> SocksOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for SocksOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SocksOutboundSettings {
        SocksOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &SocksOutboundSettings| { &m.address },
                |m: &mut SocksOutboundSettings| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &SocksOutboundSettings| { &m.port },
                |m: &mut SocksOutboundSettings| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SocksOutboundSettings>(
                "SocksOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SocksOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<SocksOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SocksOutboundSettings::new)
    }
}

impl ::protobuf::Clear for SocksOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SocksOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SocksOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShadowsocksOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub method: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShadowsocksOutboundSettings {
    fn default() -> &'a ShadowsocksOutboundSettings {
        <ShadowsocksOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ShadowsocksOutboundSettings {
    pub fn new() -> ShadowsocksOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // string method = 3;


    pub fn get_method(&self) -> &str {
        &self.method
    }
    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: ::std::string::String) {
        self.method = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method(&mut self) -> &mut ::std::string::String {
        &mut self.method
    }

    // Take field
    pub fn take_method(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.method, ::std::string::String::new())
    }

    // string password = 4;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ShadowsocksOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.method);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.method.is_empty() {
            os.write_string(3, &self.method)?;
        }
        if !self.password.is_empty() {
            os.write_string(4, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShadowsocksOutboundSettings {
        ShadowsocksOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &ShadowsocksOutboundSettings| { &m.address },
                |m: &mut ShadowsocksOutboundSettings| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &ShadowsocksOutboundSettings| { &m.port },
                |m: &mut ShadowsocksOutboundSettings| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "method",
                |m: &ShadowsocksOutboundSettings| { &m.method },
                |m: &mut ShadowsocksOutboundSettings| { &mut m.method },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &ShadowsocksOutboundSettings| { &m.password },
                |m: &mut ShadowsocksOutboundSettings| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShadowsocksOutboundSettings>(
                "ShadowsocksOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShadowsocksOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<ShadowsocksOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShadowsocksOutboundSettings::new)
    }
}

impl ::protobuf::Clear for ShadowsocksOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.method.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShadowsocksOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShadowsocksOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrojanOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrojanOutboundSettings {
    fn default() -> &'a TrojanOutboundSettings {
        <TrojanOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TrojanOutboundSettings {
    pub fn new() -> TrojanOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // string password = 3;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TrojanOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrojanOutboundSettings {
        TrojanOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &TrojanOutboundSettings| { &m.address },
                |m: &mut TrojanOutboundSettings| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &TrojanOutboundSettings| { &m.port },
                |m: &mut TrojanOutboundSettings| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &TrojanOutboundSettings| { &m.password },
                |m: &mut TrojanOutboundSettings| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrojanOutboundSettings>(
                "TrojanOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrojanOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<TrojanOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrojanOutboundSettings::new)
    }
}

impl ::protobuf::Clear for TrojanOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrojanOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrojanOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VMessOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub uuid: ::std::string::String,
    pub security: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VMessOutboundSettings {
    fn default() -> &'a VMessOutboundSettings {
        <VMessOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl VMessOutboundSettings {
    pub fn new() -> VMessOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // string uuid = 3;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string security = 4;


    pub fn get_security(&self) -> &str {
        &self.security
    }
    pub fn clear_security(&mut self) {
        self.security.clear();
    }

    // Param is passed by value, moved
    pub fn set_security(&mut self, v: ::std::string::String) {
        self.security = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security(&mut self) -> &mut ::std::string::String {
        &mut self.security
    }

    // Take field
    pub fn take_security(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.security, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VMessOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.security)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uuid);
        }
        if !self.security.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.security);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(3, &self.uuid)?;
        }
        if !self.security.is_empty() {
            os.write_string(4, &self.security)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VMessOutboundSettings {
        VMessOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &VMessOutboundSettings| { &m.address },
                |m: &mut VMessOutboundSettings| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &VMessOutboundSettings| { &m.port },
                |m: &mut VMessOutboundSettings| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &VMessOutboundSettings| { &m.uuid },
                |m: &mut VMessOutboundSettings| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "security",
                |m: &VMessOutboundSettings| { &m.security },
                |m: &mut VMessOutboundSettings| { &mut m.security },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VMessOutboundSettings>(
                "VMessOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VMessOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<VMessOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VMessOutboundSettings::new)
    }
}

impl ::protobuf::Clear for VMessOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.uuid.clear();
        self.security.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VMessOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VMessOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VLessOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub uuid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VLessOutboundSettings {
    fn default() -> &'a VLessOutboundSettings {
        <VLessOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl VLessOutboundSettings {
    pub fn new() -> VLessOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // string uuid = 3;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VLessOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(3, &self.uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VLessOutboundSettings {
        VLessOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &VLessOutboundSettings| { &m.address },
                |m: &mut VLessOutboundSettings| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &VLessOutboundSettings| { &m.port },
                |m: &mut VLessOutboundSettings| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &VLessOutboundSettings| { &m.uuid },
                |m: &mut VLessOutboundSettings| { &mut m.uuid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VLessOutboundSettings>(
                "VLessOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VLessOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<VLessOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VLessOutboundSettings::new)
    }
}

impl ::protobuf::Clear for VLessOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VLessOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VLessOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TlsOutboundSettings {
    // message fields
    pub server_name: ::std::string::String,
    pub alpn: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TlsOutboundSettings {
    fn default() -> &'a TlsOutboundSettings {
        <TlsOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TlsOutboundSettings {
    pub fn new() -> TlsOutboundSettings {
        ::std::default::Default::default()
    }

    // string server_name = 1;


    pub fn get_server_name(&self) -> &str {
        &self.server_name
    }
    pub fn clear_server_name(&mut self) {
        self.server_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_name(&mut self, v: ::std::string::String) {
        self.server_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_name(&mut self) -> &mut ::std::string::String {
        &mut self.server_name
    }

    // Take field
    pub fn take_server_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server_name, ::std::string::String::new())
    }

    // repeated string alpn = 2;


    pub fn get_alpn(&self) -> &[::std::string::String] {
        &self.alpn
    }
    pub fn clear_alpn(&mut self) {
        self.alpn.clear();
    }

    // Param is passed by value, moved
    pub fn set_alpn(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.alpn = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alpn(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.alpn
    }

    // Take field
    pub fn take_alpn(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.alpn, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TlsOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.alpn)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.server_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.server_name);
        }
        for value in &self.alpn {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.server_name.is_empty() {
            os.write_string(1, &self.server_name)?;
        }
        for v in &self.alpn {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TlsOutboundSettings {
        TlsOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server_name",
                |m: &TlsOutboundSettings| { &m.server_name },
                |m: &mut TlsOutboundSettings| { &mut m.server_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alpn",
                |m: &TlsOutboundSettings| { &m.alpn },
                |m: &mut TlsOutboundSettings| { &mut m.alpn },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TlsOutboundSettings>(
                "TlsOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TlsOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<TlsOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TlsOutboundSettings::new)
    }
}

impl ::protobuf::Clear for TlsOutboundSettings {
    fn clear(&mut self) {
        self.server_name.clear();
        self.alpn.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TlsOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TlsOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WebSocketOutboundSettings {
    // message fields
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebSocketOutboundSettings {
    fn default() -> &'a WebSocketOutboundSettings {
        <WebSocketOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl WebSocketOutboundSettings {
    pub fn new() -> WebSocketOutboundSettings {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WebSocketOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebSocketOutboundSettings {
        WebSocketOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &WebSocketOutboundSettings| { &m.path },
                |m: &mut WebSocketOutboundSettings| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WebSocketOutboundSettings>(
                "WebSocketOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WebSocketOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<WebSocketOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebSocketOutboundSettings::new)
    }
}

impl ::protobuf::Clear for WebSocketOutboundSettings {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebSocketOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebSocketOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTP2OutboundSettings {
    // message fields
    pub path: ::std::string::String,
    pub host: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTP2OutboundSettings {
    fn default() -> &'a HTTP2OutboundSettings {
        <HTTP2OutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl HTTP2OutboundSettings {
    pub fn new() -> HTTP2OutboundSettings {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HTTP2OutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTP2OutboundSettings {
        HTTP2OutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &HTTP2OutboundSettings| { &m.path },
                |m: &mut HTTP2OutboundSettings| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &HTTP2OutboundSettings| { &m.host },
                |m: &mut HTTP2OutboundSettings| { &mut m.host },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTP2OutboundSettings>(
                "HTTP2OutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTP2OutboundSettings {
        static instance: ::protobuf::rt::LazyV2<HTTP2OutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTP2OutboundSettings::new)
    }
}

impl ::protobuf::Clear for HTTP2OutboundSettings {
    fn clear(&mut self) {
        self.path.clear();
        self.host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTP2OutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTP2OutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TryAllOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    pub delay_base: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TryAllOutboundSettings {
    fn default() -> &'a TryAllOutboundSettings {
        <TryAllOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TryAllOutboundSettings {
    pub fn new() -> TryAllOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
    pub fn clear_actors(&mut self) {
        self.actors.clear();
    }

    // Param is passed by value, moved
    pub fn set_actors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.actors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.actors
    }

    // Take field
    pub fn take_actors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.actors, ::protobuf::RepeatedField::new())
    }

    // uint32 delay_base = 2;


    pub fn get_delay_base(&self) -> u32 {
        self.delay_base
    }
    pub fn clear_delay_base(&mut self) {
        self.delay_base = 0;
    }

    // Param is passed by value, moved
    pub fn set_delay_base(&mut self, v: u32) {
        self.delay_base = v;
    }
}

impl ::protobuf::Message for TryAllOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay_base = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.delay_base != 0 {
            my_size += ::protobuf::rt::value_size(2, self.delay_base, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if self.delay_base != 0 {
            os.write_uint32(2, self.delay_base)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TryAllOutboundSettings {
        TryAllOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actors",
                |m: &TryAllOutboundSettings| { &m.actors },
                |m: &mut TryAllOutboundSettings| { &mut m.actors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delay_base",
                |m: &TryAllOutboundSettings| { &m.delay_base },
                |m: &mut TryAllOutboundSettings| { &mut m.delay_base },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TryAllOutboundSettings>(
                "TryAllOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TryAllOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<TryAllOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TryAllOutboundSettings::new)
    }
}

impl ::protobuf::Clear for TryAllOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.delay_base = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TryAllOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TryAllOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandomOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomOutboundSettings {
    fn default() -> &'a RandomOutboundSettings {
        <RandomOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl RandomOutboundSettings {
    pub fn new() -> RandomOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
    pub fn clear_actors(&mut self) {
        self.actors.clear();
    }

    // Param is passed by value, moved
    pub fn set_actors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.actors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.actors
    }

    // Take field
    pub fn take_actors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.actors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RandomOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomOutboundSettings {
        RandomOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actors",
                |m: &RandomOutboundSettings| { &m.actors },
                |m: &mut RandomOutboundSettings| { &mut m.actors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandomOutboundSettings>(
                "RandomOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RandomOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<RandomOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomOutboundSettings::new)
    }
}

impl ::protobuf::Clear for RandomOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainOutboundSettings {
    fn default() -> &'a ChainOutboundSettings {
        <ChainOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ChainOutboundSettings {
    pub fn new() -> ChainOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
    pub fn clear_actors(&mut self) {
        self.actors.clear();
    }

    // Param is passed by value, moved
    pub fn set_actors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.actors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.actors
    }

    // Take field
    pub fn take_actors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.actors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChainOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainOutboundSettings {
        ChainOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actors",
                |m: &ChainOutboundSettings| { &m.actors },
                |m: &mut ChainOutboundSettings| { &mut m.actors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainOutboundSettings>(
                "ChainOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<ChainOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainOutboundSettings::new)
    }
}

impl ::protobuf::Clear for ChainOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FailOverOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    pub fail_timeout: u32,
    pub health_check: bool,
    pub check_interval: u32,
    pub failover: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FailOverOutboundSettings {
    fn default() -> &'a FailOverOutboundSettings {
        <FailOverOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl FailOverOutboundSettings {
    pub fn new() -> FailOverOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
    pub fn clear_actors(&mut self) {
        self.actors.clear();
    }

    // Param is passed by value, moved
    pub fn set_actors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.actors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.actors
    }

    // Take field
    pub fn take_actors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.actors, ::protobuf::RepeatedField::new())
    }

    // uint32 fail_timeout = 2;


    pub fn get_fail_timeout(&self) -> u32 {
        self.fail_timeout
    }
    pub fn clear_fail_timeout(&mut self) {
        self.fail_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_fail_timeout(&mut self, v: u32) {
        self.fail_timeout = v;
    }

    // bool health_check = 3;


    pub fn get_health_check(&self) -> bool {
        self.health_check
    }
    pub fn clear_health_check(&mut self) {
        self.health_check = false;
    }

    // Param is passed by value, moved
    pub fn set_health_check(&mut self, v: bool) {
        self.health_check = v;
    }

    // uint32 check_interval = 4;


    pub fn get_check_interval(&self) -> u32 {
        self.check_interval
    }
    pub fn clear_check_interval(&mut self) {
        self.check_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_check_interval(&mut self, v: u32) {
        self.check_interval = v;
    }

    // bool failover = 5;


    pub fn get_failover(&self) -> bool {
        self.failover
    }
    pub fn clear_failover(&mut self) {
        self.failover = false;
    }

    // Param is passed by value, moved
    pub fn set_failover(&mut self, v: bool) {
        self.failover = v;
    }
}

impl ::protobuf::Message for FailOverOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fail_timeout = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.health_check = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.check_interval = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failover = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.fail_timeout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.fail_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.health_check != false {
            my_size += 2;
        }
        if self.check_interval != 0 {
            my_size += ::protobuf::rt::value_size(4, self.check_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failover != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if self.fail_timeout != 0 {
            os.write_uint32(2, self.fail_timeout)?;
        }
        if self.health_check != false {
            os.write_bool(3, self.health_check)?;
        }
        if self.check_interval != 0 {
            os.write_uint32(4, self.check_interval)?;
        }
        if self.failover != false {
            os.write_bool(5, self.failover)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FailOverOutboundSettings {
        FailOverOutboundSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actors",
                |m: &FailOverOutboundSettings| { &m.actors },
                |m: &mut FailOverOutboundSettings| { &mut m.actors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fail_timeout",
                |m: &FailOverOutboundSettings| { &m.fail_timeout },
                |m: &mut FailOverOutboundSettings| { &mut m.fail_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "health_check",
                |m: &FailOverOutboundSettings| { &m.health_check },
                |m: &mut FailOverOutboundSettings| { &mut m.health_check },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "check_interval",
                |m: &FailOverOutboundSettings| { &m.check_interval },
                |m: &mut FailOverOutboundSettings| { &mut m.check_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "failover",
                |m: &FailOverOutboundSettings| { &m.failover },
                |m: &mut FailOverOutboundSettings| { &mut m.failover },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FailOverOutboundSettings>(
                "FailOverOutboundSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FailOverOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<FailOverOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FailOverOutboundSettings::new)
    }
}

impl ::protobuf::Clear for FailOverOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.fail_timeout = 0;
        self.health_check = false;
        self.check_interval = 0;
        self.failover = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FailOverOutboundSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FailOverOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Outbound {
    // message fields
    pub tag: ::std::string::String,
    pub protocol: ::std::string::String,
    pub bind: ::std::string::String,
    pub settings: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Outbound {
    fn default() -> &'a Outbound {
        <Outbound as ::protobuf::Message>::default_instance()
    }
}

impl Outbound {
    pub fn new() -> Outbound {
        ::std::default::Default::default()
    }

    // string tag = 1;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }

    // string protocol = 2;


    pub fn get_protocol(&self) -> &str {
        &self.protocol
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        &mut self.protocol
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocol, ::std::string::String::new())
    }

    // string bind = 3;


    pub fn get_bind(&self) -> &str {
        &self.bind
    }
    pub fn clear_bind(&mut self) {
        self.bind.clear();
    }

    // Param is passed by value, moved
    pub fn set_bind(&mut self, v: ::std::string::String) {
        self.bind = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bind(&mut self) -> &mut ::std::string::String {
        &mut self.bind
    }

    // Take field
    pub fn take_bind(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bind, ::std::string::String::new())
    }

    // bytes settings = 4;


    pub fn get_settings(&self) -> &[u8] {
        &self.settings
    }
    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: ::std::vec::Vec<u8>) {
        self.settings = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.settings
    }

    // Take field
    pub fn take_settings(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.settings, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Outbound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocol)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bind)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.protocol);
        }
        if !self.bind.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bind);
        }
        if !self.settings.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.settings);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if !self.protocol.is_empty() {
            os.write_string(2, &self.protocol)?;
        }
        if !self.bind.is_empty() {
            os.write_string(3, &self.bind)?;
        }
        if !self.settings.is_empty() {
            os.write_bytes(4, &self.settings)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Outbound {
        Outbound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &Outbound| { &m.tag },
                |m: &mut Outbound| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &Outbound| { &m.protocol },
                |m: &mut Outbound| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bind",
                |m: &Outbound| { &m.bind },
                |m: &mut Outbound| { &mut m.bind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "settings",
                |m: &Outbound| { &m.settings },
                |m: &mut Outbound| { &mut m.settings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Outbound>(
                "Outbound",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Outbound {
        static instance: ::protobuf::rt::LazyV2<Outbound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Outbound::new)
    }
}

impl ::protobuf::Clear for Outbound {
    fn clear(&mut self) {
        self.tag.clear();
        self.protocol.clear();
        self.bind.clear();
        self.settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Outbound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Outbound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingRule {
    // message fields
    pub target_tag: ::std::string::String,
    pub domains: ::protobuf::RepeatedField<RoutingRule_Domain>,
    pub ip_cidrs: ::protobuf::RepeatedField<::std::string::String>,
    pub mmdbs: ::protobuf::RepeatedField<RoutingRule_Mmdb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingRule {
    fn default() -> &'a RoutingRule {
        <RoutingRule as ::protobuf::Message>::default_instance()
    }
}

impl RoutingRule {
    pub fn new() -> RoutingRule {
        ::std::default::Default::default()
    }

    // string target_tag = 1;


    pub fn get_target_tag(&self) -> &str {
        &self.target_tag
    }
    pub fn clear_target_tag(&mut self) {
        self.target_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_tag(&mut self, v: ::std::string::String) {
        self.target_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_tag(&mut self) -> &mut ::std::string::String {
        &mut self.target_tag
    }

    // Take field
    pub fn take_target_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_tag, ::std::string::String::new())
    }

    // repeated .RoutingRule.Domain domains = 2;


    pub fn get_domains(&self) -> &[RoutingRule_Domain] {
        &self.domains
    }
    pub fn clear_domains(&mut self) {
        self.domains.clear();
    }

    // Param is passed by value, moved
    pub fn set_domains(&mut self, v: ::protobuf::RepeatedField<RoutingRule_Domain>) {
        self.domains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_domains(&mut self) -> &mut ::protobuf::RepeatedField<RoutingRule_Domain> {
        &mut self.domains
    }

    // Take field
    pub fn take_domains(&mut self) -> ::protobuf::RepeatedField<RoutingRule_Domain> {
        ::std::mem::replace(&mut self.domains, ::protobuf::RepeatedField::new())
    }

    // repeated string ip_cidrs = 3;


    pub fn get_ip_cidrs(&self) -> &[::std::string::String] {
        &self.ip_cidrs
    }
    pub fn clear_ip_cidrs(&mut self) {
        self.ip_cidrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_cidrs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ip_cidrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ip_cidrs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ip_cidrs
    }

    // Take field
    pub fn take_ip_cidrs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ip_cidrs, ::protobuf::RepeatedField::new())
    }

    // repeated .RoutingRule.Mmdb mmdbs = 4;


    pub fn get_mmdbs(&self) -> &[RoutingRule_Mmdb] {
        &self.mmdbs
    }
    pub fn clear_mmdbs(&mut self) {
        self.mmdbs.clear();
    }

    // Param is passed by value, moved
    pub fn set_mmdbs(&mut self, v: ::protobuf::RepeatedField<RoutingRule_Mmdb>) {
        self.mmdbs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mmdbs(&mut self) -> &mut ::protobuf::RepeatedField<RoutingRule_Mmdb> {
        &mut self.mmdbs
    }

    // Take field
    pub fn take_mmdbs(&mut self) -> ::protobuf::RepeatedField<RoutingRule_Mmdb> {
        ::std::mem::replace(&mut self.mmdbs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoutingRule {
    fn is_initialized(&self) -> bool {
        for v in &self.domains {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mmdbs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.target_tag)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.domains)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ip_cidrs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mmdbs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.target_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.target_tag);
        }
        for value in &self.domains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ip_cidrs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.mmdbs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.target_tag.is_empty() {
            os.write_string(1, &self.target_tag)?;
        }
        for v in &self.domains {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ip_cidrs {
            os.write_string(3, &v)?;
        };
        for v in &self.mmdbs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingRule {
        RoutingRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "target_tag",
                |m: &RoutingRule| { &m.target_tag },
                |m: &mut RoutingRule| { &mut m.target_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingRule_Domain>>(
                "domains",
                |m: &RoutingRule| { &m.domains },
                |m: &mut RoutingRule| { &mut m.domains },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_cidrs",
                |m: &RoutingRule| { &m.ip_cidrs },
                |m: &mut RoutingRule| { &mut m.ip_cidrs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingRule_Mmdb>>(
                "mmdbs",
                |m: &RoutingRule| { &m.mmdbs },
                |m: &mut RoutingRule| { &mut m.mmdbs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingRule>(
                "RoutingRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingRule {
        static instance: ::protobuf::rt::LazyV2<RoutingRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingRule::new)
    }
}

impl ::protobuf::Clear for RoutingRule {
    fn clear(&mut self) {
        self.target_tag.clear();
        self.domains.clear();
        self.ip_cidrs.clear();
        self.mmdbs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingRule_Domain {
    // message fields
    pub field_type: RoutingRule_Domain_Type,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingRule_Domain {
    fn default() -> &'a RoutingRule_Domain {
        <RoutingRule_Domain as ::protobuf::Message>::default_instance()
    }
}

impl RoutingRule_Domain {
    pub fn new() -> RoutingRule_Domain {
        ::std::default::Default::default()
    }

    // .RoutingRule.Domain.Type type = 1;


    pub fn get_field_type(&self) -> RoutingRule_Domain_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = RoutingRule_Domain_Type::PLAIN;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: RoutingRule_Domain_Type) {
        self.field_type = v;
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoutingRule_Domain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != RoutingRule_Domain_Type::PLAIN {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != RoutingRule_Domain_Type::PLAIN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingRule_Domain {
        RoutingRule_Domain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RoutingRule_Domain_Type>>(
                "type",
                |m: &RoutingRule_Domain| { &m.field_type },
                |m: &mut RoutingRule_Domain| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &RoutingRule_Domain| { &m.value },
                |m: &mut RoutingRule_Domain| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingRule_Domain>(
                "RoutingRule.Domain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingRule_Domain {
        static instance: ::protobuf::rt::LazyV2<RoutingRule_Domain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingRule_Domain::new)
    }
}

impl ::protobuf::Clear for RoutingRule_Domain {
    fn clear(&mut self) {
        self.field_type = RoutingRule_Domain_Type::PLAIN;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingRule_Domain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingRule_Domain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RoutingRule_Domain_Type {
    PLAIN = 0,
    DOMAIN = 1,
    FULL = 2,
}

impl ::protobuf::ProtobufEnum for RoutingRule_Domain_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RoutingRule_Domain_Type> {
        match value {
            0 => ::std::option::Option::Some(RoutingRule_Domain_Type::PLAIN),
            1 => ::std::option::Option::Some(RoutingRule_Domain_Type::DOMAIN),
            2 => ::std::option::Option::Some(RoutingRule_Domain_Type::FULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RoutingRule_Domain_Type] = &[
            RoutingRule_Domain_Type::PLAIN,
            RoutingRule_Domain_Type::DOMAIN,
            RoutingRule_Domain_Type::FULL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RoutingRule_Domain_Type>("RoutingRule.Domain.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RoutingRule_Domain_Type {
}

impl ::std::default::Default for RoutingRule_Domain_Type {
    fn default() -> Self {
        RoutingRule_Domain_Type::PLAIN
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingRule_Domain_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingRule_Mmdb {
    // message fields
    pub file: ::std::string::String,
    pub country_code: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingRule_Mmdb {
    fn default() -> &'a RoutingRule_Mmdb {
        <RoutingRule_Mmdb as ::protobuf::Message>::default_instance()
    }
}

impl RoutingRule_Mmdb {
    pub fn new() -> RoutingRule_Mmdb {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }

    // string country_code = 2;


    pub fn get_country_code(&self) -> &str {
        &self.country_code
    }
    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        &mut self.country_code
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.country_code, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoutingRule_Mmdb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.country_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        if !self.country_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.country_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        if !self.country_code.is_empty() {
            os.write_string(2, &self.country_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingRule_Mmdb {
        RoutingRule_Mmdb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file",
                |m: &RoutingRule_Mmdb| { &m.file },
                |m: &mut RoutingRule_Mmdb| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country_code",
                |m: &RoutingRule_Mmdb| { &m.country_code },
                |m: &mut RoutingRule_Mmdb| { &mut m.country_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingRule_Mmdb>(
                "RoutingRule.Mmdb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingRule_Mmdb {
        static instance: ::protobuf::rt::LazyV2<RoutingRule_Mmdb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingRule_Mmdb::new)
    }
}

impl ::protobuf::Clear for RoutingRule_Mmdb {
    fn clear(&mut self) {
        self.file.clear();
        self.country_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingRule_Mmdb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingRule_Mmdb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config {
    // message fields
    pub log: ::protobuf::SingularPtrField<Log>,
    pub inbounds: ::protobuf::RepeatedField<Inbound>,
    pub outbounds: ::protobuf::RepeatedField<Outbound>,
    pub routing_rules: ::protobuf::RepeatedField<RoutingRule>,
    pub dns: ::protobuf::SingularPtrField<DNS>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }

    // .Log log = 1;


    pub fn get_log(&self) -> &Log {
        self.log.as_ref().unwrap_or_else(|| <Log as ::protobuf::Message>::default_instance())
    }
    pub fn clear_log(&mut self) {
        self.log.clear();
    }

    pub fn has_log(&self) -> bool {
        self.log.is_some()
    }

    // Param is passed by value, moved
    pub fn set_log(&mut self, v: Log) {
        self.log = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log(&mut self) -> &mut Log {
        if self.log.is_none() {
            self.log.set_default();
        }
        self.log.as_mut().unwrap()
    }

    // Take field
    pub fn take_log(&mut self) -> Log {
        self.log.take().unwrap_or_else(|| Log::new())
    }

    // repeated .Inbound inbounds = 2;


    pub fn get_inbounds(&self) -> &[Inbound] {
        &self.inbounds
    }
    pub fn clear_inbounds(&mut self) {
        self.inbounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_inbounds(&mut self, v: ::protobuf::RepeatedField<Inbound>) {
        self.inbounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inbounds(&mut self) -> &mut ::protobuf::RepeatedField<Inbound> {
        &mut self.inbounds
    }

    // Take field
    pub fn take_inbounds(&mut self) -> ::protobuf::RepeatedField<Inbound> {
        ::std::mem::replace(&mut self.inbounds, ::protobuf::RepeatedField::new())
    }

    // repeated .Outbound outbounds = 3;


    pub fn get_outbounds(&self) -> &[Outbound] {
        &self.outbounds
    }
    pub fn clear_outbounds(&mut self) {
        self.outbounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_outbounds(&mut self, v: ::protobuf::RepeatedField<Outbound>) {
        self.outbounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outbounds(&mut self) -> &mut ::protobuf::RepeatedField<Outbound> {
        &mut self.outbounds
    }

    // Take field
    pub fn take_outbounds(&mut self) -> ::protobuf::RepeatedField<Outbound> {
        ::std::mem::replace(&mut self.outbounds, ::protobuf::RepeatedField::new())
    }

    // repeated .RoutingRule routing_rules = 4;


    pub fn get_routing_rules(&self) -> &[RoutingRule] {
        &self.routing_rules
    }
    pub fn clear_routing_rules(&mut self) {
        self.routing_rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_routing_rules(&mut self, v: ::protobuf::RepeatedField<RoutingRule>) {
        self.routing_rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routing_rules(&mut self) -> &mut ::protobuf::RepeatedField<RoutingRule> {
        &mut self.routing_rules
    }

    // Take field
    pub fn take_routing_rules(&mut self) -> ::protobuf::RepeatedField<RoutingRule> {
        ::std::mem::replace(&mut self.routing_rules, ::protobuf::RepeatedField::new())
    }

    // .DNS dns = 5;


    pub fn get_dns(&self) -> &DNS {
        self.dns.as_ref().unwrap_or_else(|| <DNS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dns(&mut self) {
        self.dns.clear();
    }

    pub fn has_dns(&self) -> bool {
        self.dns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dns(&mut self, v: DNS) {
        self.dns = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dns(&mut self) -> &mut DNS {
        if self.dns.is_none() {
            self.dns.set_default();
        }
        self.dns.as_mut().unwrap()
    }

    // Take field
    pub fn take_dns(&mut self) -> DNS {
        self.dns.take().unwrap_or_else(|| DNS::new())
    }
}

impl ::protobuf::Message for Config {
    fn is_initialized(&self) -> bool {
        for v in &self.log {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inbounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outbounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routing_rules {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.log)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inbounds)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outbounds)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routing_rules)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dns)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.log.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inbounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outbounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.routing_rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.dns.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.log.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inbounds {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outbounds {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.routing_rules {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.dns.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config {
        Config::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Log>>(
                "log",
                |m: &Config| { &m.log },
                |m: &mut Config| { &mut m.log },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Inbound>>(
                "inbounds",
                |m: &Config| { &m.inbounds },
                |m: &mut Config| { &mut m.inbounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Outbound>>(
                "outbounds",
                |m: &Config| { &m.outbounds },
                |m: &mut Config| { &mut m.outbounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingRule>>(
                "routing_rules",
                |m: &Config| { &m.routing_rules },
                |m: &mut Config| { &mut m.routing_rules },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DNS>>(
                "dns",
                |m: &Config| { &m.dns },
                |m: &mut Config| { &mut m.dns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config>(
                "Config",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config {
        static instance: ::protobuf::rt::LazyV2<Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config::new)
    }
}

impl ::protobuf::Clear for Config {
    fn clear(&mut self) {
        self.log.clear();
        self.inbounds.clear();
        self.outbounds.clear();
        self.routing_rules.clear();
        self.dns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20src/config/internal/config.proto\"3\n\x03DNS\x12\x18\n\x07servers\
    \x18\x01\x20\x03(\tR\x07servers\x12\x12\n\x04bind\x18\x02\x20\x01(\tR\
    \x04bind\"\xcc\x01\n\x03Log\x12\x20\n\x05level\x18\x01\x20\x01(\x0e2\n.L\
    og.LevelR\x05level\x12#\n\x06output\x18\x02\x20\x01(\x0e2\x0b.Log.Output\
    R\x06output\x12\x1f\n\x0boutput_file\x18\x03\x20\x01(\tR\noutputFile\"<\
    \n\x05Level\x12\t\n\x05TRACE\x10\0\x12\t\n\x05DEBUG\x10\x01\x12\x08\n\
    \x04INFO\x10\x02\x12\x08\n\x04WARN\x10\x03\x12\t\n\x05ERROR\x10\x04\"\
    \x1f\n\x06Output\x12\x0b\n\x07CONSOLE\x10\0\x12\x08\n\x04FILE\x10\x01\"\
    \xc2\x01\n\x12TUNInboundSettings\x12\x0e\n\x02fd\x18\x01\x20\x01(\x05R\
    \x02fd\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x18\n\x07addres\
    s\x18\x03\x20\x01(\tR\x07address\x12\x18\n\x07gateway\x18\x04\x20\x01(\t\
    R\x07gateway\x12\x18\n\x07netmask\x18\x05\x20\x01(\tR\x07netmask\x12\x10\
    \n\x03mtu\x18\x06\x20\x01(\x05R\x03mtu\x12(\n\x10fake_dns_exclude\x18\
    \x07\x20\x03(\tR\x0efakeDnsExclude\"*\n\x14SocksInboundSettings\x12\x12\
    \n\x04bind\x18\x01\x20\x01(\tR\x04bind\"\x7f\n\x07Inbound\x12\x10\n\x03t\
    ag\x18\x01\x20\x01(\tR\x03tag\x12\x1a\n\x08protocol\x18\x02\x20\x01(\tR\
    \x08protocol\x12\x16\n\x06listen\x18\x03\x20\x01(\tR\x06listen\x12\x12\n\
    \x04port\x18\x04\x20\x01(\rR\x04port\x12\x1a\n\x08settings\x18\x05\x20\
    \x01(\x0cR\x08settings\"H\n\x18RedirectOutboundSettings\x12\x18\n\x07add\
    ress\x18\x01\x20\x01(\tR\x07address\x12\x12\n\x04port\x18\x02\x20\x01(\r\
    R\x04port\"E\n\x15SocksOutboundSettings\x12\x18\n\x07address\x18\x01\x20\
    \x01(\tR\x07address\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\"\x7f\
    \n\x1bShadowsocksOutboundSettings\x12\x18\n\x07address\x18\x01\x20\x01(\
    \tR\x07address\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\x12\x16\n\
    \x06method\x18\x03\x20\x01(\tR\x06method\x12\x1a\n\x08password\x18\x04\
    \x20\x01(\tR\x08password\"b\n\x16TrojanOutboundSettings\x12\x18\n\x07add\
    ress\x18\x01\x20\x01(\tR\x07address\x12\x12\n\x04port\x18\x02\x20\x01(\r\
    R\x04port\x12\x1a\n\x08password\x18\x03\x20\x01(\tR\x08password\"u\n\x15\
    VMessOutboundSettings\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07addres\
    s\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\x12\x12\n\x04uuid\x18\
    \x03\x20\x01(\tR\x04uuid\x12\x1a\n\x08security\x18\x04\x20\x01(\tR\x08se\
    curity\"Y\n\x15VLessOutboundSettings\x12\x18\n\x07address\x18\x01\x20\
    \x01(\tR\x07address\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\x12\
    \x12\n\x04uuid\x18\x03\x20\x01(\tR\x04uuid\"J\n\x13TlsOutboundSettings\
    \x12\x1f\n\x0bserver_name\x18\x01\x20\x01(\tR\nserverName\x12\x12\n\x04a\
    lpn\x18\x02\x20\x03(\tR\x04alpn\"/\n\x19WebSocketOutboundSettings\x12\
    \x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"?\n\x15HTTP2OutboundSettings\
    \x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x12\n\x04host\x18\x02\
    \x20\x01(\tR\x04host\"O\n\x16TryAllOutboundSettings\x12\x16\n\x06actors\
    \x18\x01\x20\x03(\tR\x06actors\x12\x1d\n\ndelay_base\x18\x02\x20\x01(\rR\
    \tdelayBase\"0\n\x16RandomOutboundSettings\x12\x16\n\x06actors\x18\x01\
    \x20\x03(\tR\x06actors\"/\n\x15ChainOutboundSettings\x12\x16\n\x06actors\
    \x18\x01\x20\x03(\tR\x06actors\"\xbb\x01\n\x18FailOverOutboundSettings\
    \x12\x16\n\x06actors\x18\x01\x20\x03(\tR\x06actors\x12!\n\x0cfail_timeou\
    t\x18\x02\x20\x01(\rR\x0bfailTimeout\x12!\n\x0chealth_check\x18\x03\x20\
    \x01(\x08R\x0bhealthCheck\x12%\n\x0echeck_interval\x18\x04\x20\x01(\rR\r\
    checkInterval\x12\x1a\n\x08failover\x18\x05\x20\x01(\x08R\x08failover\"h\
    \n\x08Outbound\x12\x10\n\x03tag\x18\x01\x20\x01(\tR\x03tag\x12\x1a\n\x08\
    protocol\x18\x02\x20\x01(\tR\x08protocol\x12\x12\n\x04bind\x18\x03\x20\
    \x01(\tR\x04bind\x12\x1a\n\x08settings\x18\x04\x20\x01(\x0cR\x08settings\
    \"\xd5\x02\n\x0bRoutingRule\x12\x1d\n\ntarget_tag\x18\x01\x20\x01(\tR\tt\
    argetTag\x12-\n\x07domains\x18\x02\x20\x03(\x0b2\x13.RoutingRule.DomainR\
    \x07domains\x12\x19\n\x08ip_cidrs\x18\x03\x20\x03(\tR\x07ipCidrs\x12'\n\
    \x05mmdbs\x18\x04\x20\x03(\x0b2\x11.RoutingRule.MmdbR\x05mmdbs\x1au\n\
    \x06Domain\x12,\n\x04type\x18\x01\x20\x01(\x0e2\x18.RoutingRule.Domain.T\
    ypeR\x04type\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"'\n\x04Typ\
    e\x12\t\n\x05PLAIN\x10\0\x12\n\n\x06DOMAIN\x10\x01\x12\x08\n\x04FULL\x10\
    \x02\x1a=\n\x04Mmdb\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\x12!\n\
    \x0ccountry_code\x18\x02\x20\x01(\tR\x0bcountryCode\"\xba\x01\n\x06Confi\
    g\x12\x16\n\x03log\x18\x01\x20\x01(\x0b2\x04.LogR\x03log\x12$\n\x08inbou\
    nds\x18\x02\x20\x03(\x0b2\x08.InboundR\x08inbounds\x12'\n\toutbounds\x18\
    \x03\x20\x03(\x0b2\t.OutboundR\toutbounds\x121\n\rrouting_rules\x18\x04\
    \x20\x03(\x0b2\x0c.RoutingRuleR\x0croutingRules\x12\x16\n\x03dns\x18\x05\
    \x20\x01(\x0b2\x04.DNSR\x03dnsb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
